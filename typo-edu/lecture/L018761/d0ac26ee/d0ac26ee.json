{
    "title": "프로미스",
    "id": "d0ac26ee",
    "time": 1673238074681,
    "pages": [{"92acbc7a":{"title":"프로미스란","id":"92acbc7a","time":1675744868108,"content":[{"comp":"title","order":"1","enter":"2","text":"프로미스란","style":[]},{"comp":"text","order":"2","enter":"2","text":"자바스크립트에서는 비동기 처리를 위해 콜백 함수를 사용합니다. 그러나, 콜백함수가 여러번 중첩 처리되면 콜백 헬(callback hell)이 발생하는 단점이 있습니다.","style":[{"target":"(callback hell)","type":"font-size:small;"}]},{"comp":"aceEditor","order":"3","enter":"2","height":"310","start":"","text":"first(function(a){\n    second(function(b){\n        third(function(c){\n            fourth(function(d){\n                fifth(function(e){\n                    // use e\n                });\n            });\n        });\n    });\n});","style":[]},{"comp":"text","order":"4","enter":"3","text":"이는 코드가 복잡해져 가독성이 떨어질 뿐 아니라, 프로그래밍 코드상에 실수를 유발시키기도 합니다.","style":[]},{"comp":"text","order":"5","enter":"0","text":"따라서, ES6에 이러한 단점을 보완하기 위해 추가된 것이 프로미스(Promise)입니다.","style":[{"target":"프로미스","type":"font-size:xx-large;color:#00A05B;"},{"target":"(Promise)","type":"font-size:small;"}]},{"comp":"check","order":"6","enter":"0","id":"c52d4b01","text":"프로미스는 '약속'을 의미하며, 비동기 처리를 위한 객체 입니다. ","style":[{"target":"비동기 처리를 위한 객체","type":"box-shadow: inset 0 -6px 0 #E0E6FF;"}]},{"comp":"text","order":"7","enter":"2","text":"주로 네트워크 통신이나 파일을 읽어오는 작업에서 활용할 수 있습니다.","style":[]},{"comp":"check","order":"8","enter":"2","id":"88ebf06d","text":"이는 Promise 생성자 함수로 생성할 수 있습니다. ","style":[{"target":"Promise 생성자 함수로 생성","type":"background:#0078AF;color:white;padding:2px;"}]},{"comp":"aceEditor","order":"9","enter":"3","height":"50","start":"","text":"const promise = new Promise();","style":[]},{"comp":"text","order":"10","enter":"0","text":"프로미스는 매개변수로 실행함수(executor)를 받습니다. ","style":[{"target":"(executor)","type":"font-size:small;"}]},{"comp":"direction","order":"11","enter":"0","codeId":"644ec1ce","targetLine":"","title":"프로미스","text":"다음의 코드를 따라서 입력하고 실행해 보세요.","bgCode":"","style":[]},{"comp":"aceEditor","order":"12","enter":"12","height":"105","start":"","text":"const promise = new Promise((resolve, reject) => {\n    print('automatically run');\n});","style":[]},{"comp":"text","order":"13","enter":"2","text":"코드를 실행하면 'automatically run'이 바로 출력되는 것을 확인할 수 있습니다.","style":[]},{"comp":"par","order":"14","enter":"3","style":"margin:0 auto;width:500px;padding: 5px;background: #E6E6EF;font-family:IBM Plex Mono;font-size:17px;border-radius:5px;color: #0051DD;","text":">> automatically run"},{"comp":"check","order":"15","enter":"0","id":"b51aa449","text":"주의할 점은 프로미스가 생성되면 실행함수가 자동적으로 실행된다는 점입니다.","style":[]},{"comp":"text","order":"16","enter":"0","text":"따라서, 불필요한 네트워크 통신이 이뤄지지 않도록 필요한 상황에 맞게 프로미스를 생성하도록 해야 합니다.","style":[]},{"comp":"text","order":"17","enter":"3","text":"","style":[]},{"comp":"check","order":"18","enter":"2","id":"8bccb65b","text":"프로미스는 다음의 상태 정보를 가집니다.","style":[]},{"comp":"image","order":"19","enter":"3","width":"550","src":"./lecture/9627cb42/d0ac26ee/1_1.png","style":[]},{"comp":"text","order":"20","enter":"2","text":"Promise 생성자를 사용해 프로미스가 생성된 상태는 pending 상태로 볼 수 있습니다.","style":[]},{"comp":"text","order":"21","enter":"6","text":"그리고 비동기 처리가 수행된 상태는 fulfilled, rejected로 나뉘며, 각각은 성공과 실패 상태를 의미합니다.","style":[]}]}},{"d0952c00":{"title":"resolve와 reject","id":"d0952c00","time":1675748357462,"content":[{"comp":"title","order":"1","enter":"2","text":"resolve와 reject","style":[]},{"comp":"text","order":"2","enter":"2","text":"프로미스의 사용은 크게 다음의 두 부분으로 나누어 볼 수 있습니다. ","style":[]},{"comp":"check","order":"3","enter":"2","id":"04ccc270","text":"비동기 처리를 수행해서 데이터를 만들어 내는 producer와 비동기 처리 결과를 받아와 필요한 작업을 수행하는 consumer 입니다.","style":[]},{"comp":"text","order":"4","enter":"2","text":"먼저, producer는 프로미스를 선언하는 부분 입니다.","style":[]},{"comp":"aceEditor","order":"5","enter":"3","height":"280","start":"","text":"function doit(param){\n    return new Promise((resolve, reject) => {\n        if(param) {\n            resolve('success');\n        }\n        else {\n            reject(Error('failed'));\n        }\n    });\n}","style":[]},{"comp":"text","order":"6","enter":"0","text":"위의 코드를 살펴보면, doit 함수에서 프로미스를 생성해 반환합니다. ","style":[]},{"comp":"check","order":"7","enter":"2","id":"e9033925","text":"프로미스 실행함수에서는 doit 함수의 매개변수가 있으면, resolve를 호출하고, 없으면 reject를 호출합니다.","style":[]},{"comp":"text","order":"8","enter":"2","text":"resolve는 비동기 처리의 성공이며, reject는 비동기 처리의 실패시 전달한 값을 인수로 사용합니다.","style":[]},{"comp":"text","order":"9","enter":"0","text":"따라서 doit 함수가 매개변수를 가지고 있으면 'success'가 전달되고,","style":[]},{"comp":"text","order":"10","enter":"2","text":"매개변수가 없어 비동기 처리가 실패했다고 판단하면 Error 함수를 사용해 failed 메시지를 전달합니다.","style":[]},{"comp":"image","order":"11","enter":"6","width":"400","src":"./lecture/9627cb42/d0ac26ee/2_1.png","style":[]}]}},{"210dbedd":{"title":"then과 catch","id":"210dbedd","time":1675749295890,"content":[{"comp":"title","order":"1","enter":"2","text":"then과 catch","style":[]},{"comp":"text","order":"2","enter":"2","text":"이번에는 producer에서 만들어 낸 데이터를 전달받아 처리하는 consumer 부분을 살펴보겠습니다.","style":[]},{"comp":"direction","order":"3","enter":"0","codeId":"31873f48","targetLine":"","title":"프로미스 then","text":"다음의 코드를 따라서 입력하고 실행해 보세요.","bgCode":"","style":[]},{"comp":"aceEditor","order":"4","enter":"12","height":"130","start":"","text":"const doit = new Promise((resolve, reject) => {\n    resolve('성공');\n});\ndoit.then(data => print(data));","style":[]},{"comp":"check","order":"5","enter":"2","id":"de3cee76","text":"resolve나 reject로 전달받은 데이터를 처리하기 위해서 then 메서드를 사용합니다.","style":[]},{"comp":"text","order":"6","enter":"2","text":"4라인의 코드를 보면 then 메서드가 사용되었고, 전달받은 데이터를 print 함수로 출력하도록 했습니다.","style":[]},{"comp":"aceEditor","order":"7","enter":"2","height":"50","start":"4","text":"doit.then(data => print(data));","style":[]},{"comp":"text","order":"8","enter":"2","text":"프로미스 실행함수에서 resolve를 호출하면서 '성공'을 전달하였으므로,  다음과 같이 출력됩니다.","style":[]},{"comp":"par","order":"9","enter":"3","style":"margin:0 auto;width:500px;padding: 5px;background: #E6E6EF;font-family:IBM Plex Mono;font-size:17px;border-radius:5px;color: #0051DD;","text":">> 성공"},{"comp":"text","order":"10","enter":"3","text":"그렇다면 비동기 처리가 실패된 상태인 reject는 어떻게 해야 할까요?","style":[]},{"comp":"check","order":"11","enter":"2","id":"e524ba0c","text":"프로미스의 실행함수의 2번째 매개변수가 reject이므로, then 메서드의 2번째 인수로 처리합니다. ","style":[]},{"comp":"direction","order":"12","enter":"0","codeId":"0b3465ab","targetLine":"","title":"프로미스 then","text":"다음의 코드를 따라서 입력하고 실행해 보세요.","bgCode":"","style":[]},{"comp":"aceEditor","order":"13","enter":"12","height":"140","start":"","text":"const doit = new Promise((resolve, reject) => {\n    reject('실패');\n});\ndoit.then(data => print(data), reason => print(`error: ${reason}`));","style":[]},{"comp":"text","order":"14","enter":"0","text":"위에서 doit 프로미스는 reject를 호출합니다. ","style":[]},{"comp":"aceEditor","order":"15","enter":"3","height":"50","start":"2","text":"    reject('실패');","style":[]},{"comp":"check","order":"16","enter":"0","id":"acc59f35","text":"그리고 then 메서드의 2번째 인수에서 전달받은 reason을 print 함수로 출력합니다.","style":[]},{"comp":"aceEditor","order":"17","enter":"3","height":"50","start":"4","text":"doit.then(data => print(data), reason => print(`error: ${reason}`));","style":[]},{"comp":"text","order":"18","enter":"2","text":"따라서, reject로 전달한 값인 '실패'가 출력됩니다.","style":[]},{"comp":"par","order":"19","enter":"5","style":"margin:0 auto;width:500px;padding: 5px;background: #E6E6EF;font-family:IBM Plex Mono;font-size:17px;border-radius:5px;color: #0051DD;","text":">> error: 실패"},{"comp":"check","order":"20","enter":"2","id":"cb68228b","text":"그런데, reject의 처리는 then 메서드의 2번째 인수보다는 catch 메서드로 처리하는 것이 좋습니다.","style":[]},{"comp":"direction","order":"21","enter":"0","codeId":"e825775e","targetLine":"5","title":"프로미스 catch","text":"다음의 5라인의 코드를 따라서 입력하고 실행해 보세요.","bgCode":"const doit = new Promise((resolve, reject) => {\n    reject('실패');\n});\ndoit.then(data => print(data))\n","style":[]},{"comp":"aceEditor","order":"22","enter":"12","height":"150","start":"","text":"const doit = new Promise((resolve, reject) => {\n    reject('실패');\n});\ndoit.then(data => print(data))\n    .catch(reason => print(`error: ${reason}`));","style":[]},{"comp":"text","order":"23","enter":"2","text":"catch 메서드를 사용하면 then 메서드의 2번째 인수를 사용해 reject를 처리한 것과 동일한 결과를 얻습니다. ","style":[]},{"comp":"text","order":"24","enter":"0","text":"then 메서드는 프로미스를 반환합니다. 따라서 체이닝 형태로도 사용할 수 있습니다.","style":[]},{"comp":"check","order":"25","enter":"2","id":"c427ab72","text":"체인 상태에서 첫번째 콜백함수에서 오류가 발생하는 경우, 이는 reject가 아닌 상태에서 발생하는 오류이므로 다음 체인 콜백함수의 실행이 되지 않을 가능성이 있습니다.","style":[]},{"comp":"text","order":"26","enter":"2","text":"그러나 catch 메서드를 사용하면 오류를 잡아낼 수 있습니다. ","style":[]},{"comp":"aceEditor","order":"27","enter":"3","height":"200","start":"","text":"const doit = new Promise((resolve, reject) => {\n    resolve('성공');\n});\ndoit.then(data => JSON.parse(data), data => print(`error : ${data}`))\n    //.catch(data => print(`error : ${data}`))\n    .then(data => print(data));","style":[]},{"comp":"text","order":"28","enter":"2","text":"위의 코드에서 JSON 문자열이 아닌 '성공' 문자열 데이터에 JSON.parse를 사용했으므로, 오류가 발생합니다. ","style":[]},{"comp":"text","order":"29","enter":"0","text":"이는 reject 상태가 아닌 오류로 그대로 실행하면 2번째 then 메서드의 콜백함수도 실행되지 않습니다. ","style":[]},{"comp":"text","order":"30","enter":"3","text":"그러나, catch 메서드로 처리하면 오류를 발견할 수 있을 뿐 아니라, 체인으로 연결된 2번째 then 메서드로 처리됩니다. ","style":[]},{"comp":"direction","order":"31","enter":"","codeId":"dc366792","targetLine":"5","title":"프로미스 catch","text":"에디터를 열고, 코드를 그대로 실행해 본 다음, 5번째 주석 처리된 코드를 주석 해제해 실행해 차이를 살펴보세요.","bgCode":"const doit = new Promise((resolve, reject) => {\n    resolve('성공');\n});\ndoit.then(data => JSON.parse(data), data => print(`error : ${data}`))\n    //.catch(data => print(`error : ${data}`))\n    .then(data => print(data));","style":[]},{"comp":"sup","order":"32","enter":"14","text":"* 주석해제할 코드라인에 커서를 위치시킨 후, ctrl + / 키를 사용","style":[{"target":"* 주석해제할 코드라인에 커서를 위치시킨 후, ctrl + / 키를 사용","type":"color: #D86500; font-size: 11px;"}]},{"comp":"text","order":"33","enter":"2","text":"catch 메서드를 사용한 경우, 다음과 같이 출력되는 것을 확인할 수 있습니다.","style":[]},{"comp":"par","order":"34","enter":"6","style":"margin:0 auto;width:700px;padding: 5px;background: #E6E6EF;font-family:IBM Plex Mono;font-size:15px;border-radius:5px;color: #0051DD;","text":">> error : SyntaxError: Unexpected token '성', \"성공\" is not valid JSON\n>> undifined"}]}},{"6062de8c":{"title":"프로미스 체이닝","id":"6062de8c","time":1675749405598,"content":[{"comp":"title","order":"1","enter":"2","text":"프로미스 체이닝","style":[]},{"comp":"text","order":"2","enter":"2","text":"프로미스는 then, catch 메서드를 사용해 연결상태로 사용할 수 있습니다.","style":[]},{"comp":"direction","order":"3","enter":"0","codeId":"6d0ae3b0","targetLine":"1","title":"프로미스 체이닝","text":"다음의 코드를 살펴보겠습니다.","bgCode":"new Promise((resolve, reject) => {\n    setTimeout(() => {resolve(100)}, 1000);\n}).then(data => {\n    print(data);\n    return data * 2;\n}).then(data => {\n    print(data);\n    return data * 2;\n}).then(data => print(data));","style":[]},{"comp":"aceEditor","order":"4","enter":"3","height":"260","start":"","text":"new Promise((resolve, reject) => {\n    setTimeout(() => {resolve(100)}, 1000);\n}).then(data => {\n    print(data);\n    return data * 2;\n}).then(data => {\n    print(data);\n    return data * 2;\n}).then(data => print(data));","style":[]},{"comp":"check","order":"5","enter":"0","id":"23b54d15","text":"프로미스가 setTimeout을 사용해 1초 후에 100을 전달합니다. ","style":[]},{"comp":"text","order":"6","enter":"2","text":"그리고 3개의 then 메서드가 연결되었습니다. 이와 같은 사용을 프로미스 체이닝이라고 합니다.","style":[]},{"comp":"check","order":"7","enter":"2","id":"b5798118","text":"1, 2번째 then 메서드는 전달받은 data를 출력하고, 2를 곱해서 반환해줍니다. 그리고 마지막 then 메서드는 data를 출력합니다.","style":[]},{"comp":"text","order":"8","enter":"2","text":"data가 체인을 통해 전달되므로 다음과 같은 결과를 얻을 수 있습니다.","style":[]},{"comp":"par","order":"9","enter":"5","style":"margin:0 auto;width:500px;padding: 5px;background: #E6E6EF;font-family:IBM Plex Mono;font-size:17px;border-radius:5px;color: #0051DD;","text":">> 100\n>> 200\n>> 400"},{"comp":"text","order":"10","enter":"","text":"위의 코드는 다음과 같이 축약된 형태로도 사용 가능합니다.","style":[]},{"comp":"aceEditor","order":"11","enter":"3","height":"290","start":"","text":"const doit = new Promise((resolve, reject) => {\n    setTimeout(() => {resolve(100)}, 1000);\n});\nfunction double(n) {\n    print(n);\n    return n * 2;\n}\ndoit.then(data => double(data))\n    .then(double)\n    .then(print);","style":[]},{"comp":"check","order":"12","enter":"2","id":"73f81a1c","text":"8라인과 같이 then 메서드의 콜백함수 수행문이 한 줄이고, 매개변수를 그대로 전달하는 형태라면 ","style":[]},{"comp":"par","order":"13","enter":"3","style":"text-align:center;margin:0 auto;width:400px;background: #282A35;color:white;border-radius:10px;padding:10px;font-family:IBM Plex Mono;font-size:17px;","text":"then( <font color=orange>data</font> => <font color=#93E6FF >double</font>(<font color=orange>data</font>) )"},{"comp":"check","order":"14","enter":"2","id":"dc738ded","text":"다음과 같이 축약해서 함수명만 사용할 수 있습니다.","style":[]},{"comp":"par","order":"15","enter":"4","style":"text-align:center;margin:0 auto;width:400px;background: #282A35;color:white;border-radius:10px;padding:10px;font-family:IBM Plex Mono;font-size:17px;","text":"then( <font color=#93E6FF >double</font> )"},{"comp":"text","order":"16","enter":"2","text":"then 콜백함수에서 전달받은 값을 처리하고 결과값을 반환하고 있는데, 이때, 다음과 같이 새로운 프로미스를 반환할 수도 있습니다.","style":[]},{"comp":"direction","order":"17","enter":"0","codeId":"303c1c9f","targetLine":"9","title":"프로미스 체이닝","text":"9-11라인과 같이 프로미스를 반환하도록 따라서 입력하고 실행해 보세요.","bgCode":"const doit = new Promise((resolve, reject) => {\n    setTimeout(() => {resolve(100)}, 1000);\n});\nfunction double(n) {\n    print(n);\n    return n * 2;\n}\ndoit.then(double)\n    .then(\n        \n    )\n    .then(print);","style":[]},{"comp":"aceEditor","order":"18","enter":"12","height":"170","start":"8","text":"doit.then(double)\n    .then(data => new Promise((resolve, reject) => {\n        setTimeout(() => {resolve(double(data))}, 1000);\n    }))\n    .then(print);","style":[]},{"comp":"text","order":"19","enter":"","text":"프로미스를 반환한 결과,","style":[]},{"comp":"text","order":"20","enter":"2","text":"숫자 100이 출력되고, 1초 지연시간 이후 다음의 값들이 출력되는 것을 확인할 수 있습니다.","style":[]},{"comp":"image","order":"21","enter":"6","width":"300","src":"./lecture/9627cb42/d0ac26ee/4_1.gif","style":[]}]}},{"eb76edcc":{"title":"프로미스의 정적 메서드","id":"eb76edcc","time":1675749351288,"content":[{"comp":"title","order":"1","enter":"2","text":"프로미스의 정적 메서드","style":[]},{"comp":"text","order":"2","enter":"2","text":"프로미스 객체는 4가지 정적 메서드를 가지고 있습니다.","style":[]},{"comp":"text","order":"3","enter":"2","text":"(1) Promise.resolve","style":[{"target":"(1) Promise.resolve","type":"font-size:x-large;"}]},{"comp":"check","order":"4","enter":"2","id":"d70cdf3b","text":"Promise.resolve 메서드는 인자로 전달된 값으로 resolve 처리하는 Promise를 생성합니다.","style":[]},{"comp":"text","order":"5","enter":"0","text":"다음과 같은 프로미스가 있을 때, ","style":[]},{"comp":"aceEditor","order":"6","enter":"3","height":"80","start":"","text":"new Promise(resolve => resolve('hello'))\n    .then(print); // hello","style":[]},{"comp":"text","order":"7","enter":"2","text":"Promise.resolve 메서드를 사용하면 보다 간편하게 사용할 수 있습니다.","style":[]},{"comp":"direction","order":"8","enter":"0","codeId":"263dc544","targetLine":"","title":"Promise.resolve 메서드","text":"다음의 코드를 따라서 입력하고 실행해 보세요.","bgCode":"","style":[]},{"comp":"aceEditor","order":"9","enter":"12","height":"50","start":"","text":"Promise.resolve('hello').then(print);","style":[]},{"comp":"text","order":"10","enter":"2","text":"Promise 생성자를 사용한 프로미스 생성코드와 동일한 결과를 출력하는 것을 확인할 수 있습니다.","style":[]},{"comp":"par","order":"11","enter":"5","style":"margin:0 auto;width:500px;padding: 5px;background: #E6E6EF;font-family:IBM Plex Mono;font-size:17px;border-radius:5px;color: #0051DD;","text":">> hello"},{"comp":"text","order":"12","enter":"2","text":"(2) Promise.reject","style":[{"target":"(2) Promise.reject","type":"font-size: x-large;"}]},{"comp":"check","order":"13","enter":"2","id":"ee60c0bf","text":"Promise.reject 메서드는 인자로 전달된 값으로 reject를 처리하는 Promise를 생성합니다.","style":[]},{"comp":"aceEditor","order":"14","enter":"3","height":"80","start":"","text":"new Promise((resolve, reject) => reject(Error('error')))\n    .catch(alert);","style":[]},{"comp":"text","order":"15","enter":"2","text":"위의 코드는 'error' 메시지로 reject를 처리하는 프로미스 생성과 catch 메서드로 전달된 메시지를 alert 창으로 보여줍니다.","style":[]},{"comp":"direction","order":"16","enter":"0","codeId":"930372fb","targetLine":"1","title":"Promise.reject 메서드","text":"이를 Promise.reject 메서드로 수정해서 입력하고 실행해 보세요.","bgCode":"\n    .catch(alert);","style":[]},{"comp":"aceEditor","order":"17","enter":"12","height":"80","start":"","text":"Promise.reject(Error('error'))\n    .catch(alert);","style":[]},{"comp":"text","order":"18","enter":"2","text":"(3) Promise.all","style":[{"target":"(3) Promise.all","type":"font-size:x-large;"}]},{"comp":"check","order":"19","enter":"2","id":"ec8d9112","text":"Promise.all 메서드는 프로미스 배열을 인자로 전달받아 모든 프로미스를 처리하고, 처리결과 값을 담은 배열로 반환합니다.","style":[]},{"comp":"aceEditor","order":"20","enter":"2","height":"190","start":"","text":"Promise.all([\n    new Promise(resolve => setTimeout(() => resolve(1), 1000)),\n    new Promise(resolve => setTimeout(() => resolve(2), 3000)),\n    new Promise(resolve => setTimeout(() => resolve(3), 2000))\n    ])\n    .then(print);","style":[]},{"comp":"text","order":"21","enter":"0","text":"위는 3개 프로미스 배열을 인수로 사용하고 있습니다. ","style":[]},{"comp":"text","order":"22","enter":"2","text":"각 프로미스는 병렬로 처리되며, setTimeout으로 시간차를 두고 resolve를 처리하고 있습니다.","style":[]},{"comp":"check","order":"23","enter":"2","id":"4d47d5df","text":"따라서 3초 후에 모든 프로미스의 처리 결과가 담긴 배열이 출력됩니다.","style":[]},{"comp":"par","order":"24","enter":"3","style":"margin:0 auto;width:500px;padding: 5px;background: #E6E6EF;font-family:IBM Plex Mono;font-size:17px;border-radius:5px;color: #0051DD;","text":">> [1, 2, 3]"},{"comp":"text","order":"25","enter":"2","text":"2번째 프로미스가 3초로 가장 늦게 resolve 처리되지만, 결과는 배열의 2번째 인덱스에 저장됩니다.","style":[]},{"comp":"check","order":"26","enter":"0","id":"f2690e5e","text":"또, Promise.all로 사용된 프로미스 중 하나라도 오류가 발생하면 catch로 처리됩니다.","style":[]},{"comp":"aceEditor","order":"27","enter":"5","height":"180","start":"","text":"Promise.all([\n    new Promise((resolve, reject) => setTimeout(() => reject(Error('error')), 1000)),\n    new Promise(resolve => setTimeout(() => resolve(2), 3000)),\n    new Promise(resolve => setTimeout(() => resolve(3), 2000))\n    ])\n    .then(print).catch(alert);","style":[]},{"comp":"check","order":"28","enter":"0","id":"3f7fb530","text":"Promise.all 메서드에 사용하는 이터러블 요소가 프로미스가 아닌 일반 값으로도 사용할 수 있는데, 이는 일반값을 resolve 처리하는 프로미스로 간주됩니다.","style":[]},{"comp":"aceEditor","order":"29","enter":"5","height":"180","start":"","text":"Promise.all([\n    100, // Promise.resolve(100),\n    200, \n    300\n    ])\n    .then(print);","style":[]},{"comp":"text","order":"30","enter":"2","text":"(4) Promise.race","style":[{"target":"(4) Promise.race","type":"font-size:x-large;"}]},{"comp":"check","order":"31","enter":"2","id":"e8988cba","text":"Promise.race 메서드는 Promise.all 메서드와 동일하게 이터러블을 인자로 받습니다. 차이점은 가장 먼저 처리되는 프로미스의 결과를 반환합니다.","style":[]},{"comp":"direction","order":"32","enter":"0","codeId":"130259c3","targetLine":"","title":"Promise.race 메서드","text":"다음의 코드를 실행해 보세요.","bgCode":"Promise.race([\n    new Promise(resolve => setTimeout(() => resolve(100), 2000)),\n    new Promise((resolve, reject) => setTimeout(() => reject(Error('error')), 3000)),\n    new Promise(resolve => setTimeout(() => resolve(200), 1000))\n    ])\n    .then(print).catch(alert);","style":[]},{"comp":"aceEditor","order":"33","enter":"12","height":"190","start":"","text":"Promise.race([\n    new Promise(resolve => setTimeout(() => resolve(100), 2000)),\n    new Promise((resolve, reject) => setTimeout(() => reject(Error('error')), 3000)),\n    new Promise(resolve => setTimeout(() => resolve(200), 1000))\n    ])\n    .then(print).catch(alert);","style":[]},{"comp":"text","order":"34","enter":"2","text":"코드를 실행하면 1초 후에 처리되는 3번째 프로미스의 결과값이 출력되고 종료됩니다. ","style":[]},{"comp":"par","order":"35","enter":"3","style":"margin:0 auto;width:500px;padding: 5px;background: #E6E6EF;font-family:IBM Plex Mono;font-size:17px;border-radius:5px;color: #0051DD;","text":">> 200"},{"comp":"text","order":"36","enter":"5","text":"이후에 reject 프로미스가 catch로 처리되거나, 1번째 프로미스의 결과값 처리는 무시됩니다.","style":[]},{"comp":"text","order":"37","enter":"0","text":"이로써 4가지 프로미스의 정적 메서드에 대해 알아보았습니다. Promise.resolve, Promise.reject 메서드는 async/await 문법으로 대체할 수 있습니다.","style":[]},{"comp":"sub","order":"38","enter":"6","text":"* async/await 관련 : <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/async_function\" target=\"_blank\">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/async_function</a>","style":[{"target":"* async/await 관련 : <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/async_function\" target=\"_blank\">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/async_function</a>","type":"font-size:small;font-weight:100;color:gray;"}]},{"comp":"check","order":"39","enter":"2","id":"93d2f469","text":"교재학습이 완료되었습니다.","style":[{"target":"교재학습이 완료되었습니다.","type":"font-size:20px;color:gray;"}]},{"comp":"ending","order":"40","enter":"6","style":[]}]}}], 
    "icon": "undraw_reminder_re_fe15.svg"
}